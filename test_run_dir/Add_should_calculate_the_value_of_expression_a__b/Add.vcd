$date
2024-10-01T15:58+0000
$end
$version
0.2
$end
$comment

$end
$timescale 1ns  $end
$scope module Add $end
 $var wire 4 ! shift $end
 $var wire 1 " resultOverflow $end
 $var wire 7 # shiftedCalcValue $end
 $var wire 1 $ subtract $end
 $var wire 8 % a_data $end
 $var wire 4 & resultFraction $end
 $var wire 1 ' compare $end
 $var wire 1 ( is0 $end
 $var wire 1 ) subtraction $end
 $var wire 4 * tempExponent $end
 $var wire 1 + isResultNaN $end
 $var wire 2 , roundingMode $end
 $var wire 4 - exponent_1 $end
 $var wire 1 . isNaN $end
 $var wire 1 / resultSign $end
 $var wire 5 0 roundedFraction $end
 $var wire 7 1 tempFraction $end
 $var wire 8 2 greaterOperand_data $end
 $var wire 8 3 paddedCalcValue $end
 $var wire 4 4 smallerOperandFraction $end
 $var wire 8 5 smallerOperand_data $end
 $var wire 10 6 shiftedFraction_shifted $end
 $var wire 1 7 enable $end
 $var wire 1 8 addOne $end
 $var wire 1 9 reset $end
 $var wire 4 : resultExponent $end
 $var wire 7 ; shift_1 $end
 $var wire 4 < fraction $end
 $var wire 7 = smallerOperandFraction_1 $end
 $var wire 1 > sign $end
 $var wire 1 ? overflow $end
 $var wire 5 @ exponent $end
 $var wire 7 A greaterOperandFraction_1 $end
 $var wire 1 B clock $end
 $var wire 4 C greaterOperandFraction $end
 $var wire 8 D b_data $end
 $var wire 1 E isOnlySmallerDenormalized $end
 $var wire 8 F originalCalculatedValue $end
 $var wire 8 G calculatedValue $end
 $var wire 1 H isResult0 $end
 $var wire 1 I isInfty $end
$upscope $end
$enddefinitions $end
$dumpvars
b0000000000 6
b0000 C
07
08
09
b00000000 %
0>
0?
b0000000 ;
0B
b0000000 =
0E
b00 ,
b0000000 A
0H
b00000000 3
0I
b00000000 2
b00000000 5
b00000 0
b00000000 G
b0000 !
b00000000 F
b0000000 1
b0000000 #
b0000 -
b0000 *
b00000000 D
b0000 &
b00000 @
b0000 4
0"
0$
0'
b0000 <
0(
0)
b0000 :
0+
0.
0/
$end
#0
19
b0000110 ;
#1
1B
#6
b1011000 A
0B
b1011 C
b01001011 D
0E
b01011101 F
b01011101 G
b0100 !
b1011101 #
b00101010 %
b1100 &
0'
b1001 *
b1001 -
b01100 0
b1011101 1
b01001011 2
b01011101 3
b1010 4
b00101010 5
b0000101000 6
18
09
b1001 :
b0000000 ;
b0000101 =
#11
1B
#16
0B
#21
1B
#26
b01001 @
0B
17
b1100 <
#31
1B
#36
0B
#41
1B
#46
0B
b1010011 #
b10101010 %
b1010 &
b01010011 F
b01010011 G
1)
b01010 0
b1010011 1
b01010011 3
b10101010 5
08
b1010 <
#51
1B
#56
0B
#61
1B
#66
b01010 @
b1111000 A
0B
b1111101 #
b1111 C
b01001111 D
b00101010 %
b1000 &
b01111101 F
b01111101 G
0)
b10000 0
b1111101 1
b01001111 2
b01111101 3
b00101010 5
18
b1010 :
b1000 <
#71
1B
#76
0B
#81
1B
#86
b00000 @
b1010000 A
0B
b1010 C
b10101010 D
b00000000 F
b00000000 G
1H
b0000 !
b0000000 #
b0000 &
1(
1)
b0000 *
b0101 -
1/
b00000 0
b0000000 1
b10101010 2
b00000000 3
b1010000000 6
08
b0000 :
b0000110 ;
b0000 <
b1010000 =
1>
#91
1B
#96
0B
#101
1B
#106
b01111 @
b1010 !
0B
b1001111 #
b11111010 D
b1010 &
b01001111 F
b01001111 G
0(
0H
b1111 *
b1111 -
b01010 0
b1001111 1
b11111010 2
b01001111 3
b0000001010 6
18
b1111 :
b0000000 ;
b1010 <
b0000001 =
#111
1B
#116
0B
#121
1B
#126
0B
b00000000 D
b00000000 %
07

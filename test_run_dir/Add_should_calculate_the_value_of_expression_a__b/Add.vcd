$date
2024-10-01T14:09+0000
$end
$version
0.2
$end
$comment

$end
$timescale 1ns  $end
$scope module Add $end
 $var wire 1 ! result_overflow $end
 $var wire 1 " subtract $end
 $var wire 8 # a_data $end
 $var wire 7 $ result_smallerOperandFraction_1 $end
 $var wire 5 % result_roundedFraction $end
 $var wire 5 & result_z_hi_7 $end
 $var wire 5 ' result_z_hi_8 $end
 $var wire 5 ( result_z_hi $end
 $var wire 1 ) result_isResult0 $end
 $var wire 1 * result_compare $end
 $var wire 8 + result $end
 $var wire 1 , result_isOnlySmallerDenormalized $end
 $var wire 7 - result_shiftedCalcValue $end
 $var wire 4 . result_shift $end
 $var wire 4 / result_finalExponent $end
 $var wire 2 0 roundingMode $end
 $var wire 8 1 z $end
 $var wire 4 2 result_greaterOperandFraction $end
 $var wire 8 3 result_paddedCalcValue $end
 $var wire 1 4 saturationMode $end
 $var wire 7 5 result_tempFraction $end
 $var wire 7 6 result_shift_1 $end
 $var wire 1 7 result_subtraction $end
 $var wire 10 8 result_shiftedFraction_shifted $end
 $var wire 4 9 result_z_lo_1 $end
 $var wire 4 : result_z_lo_2 $end
 $var wire 5 ; result_z_hi_5 $end
 $var wire 5 < result_z_hi_6 $end
 $var wire 4 = result_z_hi_3 $end
 $var wire 5 > result_z_hi_4 $end
 $var wire 4 ? result_z_hi_1 $end
 $var wire 4 @ result_z_hi_2 $end
 $var wire 4 A result_finalFraction $end
 $var wire 4 B result_exponent $end
 $var wire 8 C result_originalCalculatedValue $end
 $var wire 1 D enable $end
 $var wire 1 E result_isResultNaN $end
 $var wire 1 F result_addOne $end
 $var wire 1 G reset $end
 $var wire 4 H result_smallerOperandFraction $end
 $var wire 1 I result_sign $end
 $var wire 4 J result_tempExponent $end
 $var wire 7 K result_greaterOperandFraction_1 $end
 $var wire 1 L clock $end
 $var wire 4 M result_z_lo $end
 $var wire 8 N b_data $end
 $var wire 8 O result_smallerOperand_data $end
 $var wire 8 P result_calculatedValue $end
 $var wire 8 Q result_greaterOperand_data $end
$upscope $end
$enddefinitions $end
$dumpvars
b0000000000 8
04
07
b00 0
b00000 %
0D
b00000 '
0E
b00000 &
0F
0G
b00000 (
0I
0L
b00000 ;
b00000000 C
b00000 <
b00000 >
b0000 2
b0000 .
b0000 /
b0000 =
b0000 :
b00000000 O
b0000 9
b00000000 N
b00000000 Q
b00000000 P
b0000000 K
b00000000 +
b0000 B
b0000 @
b0000 A
b0000 ?
b00000000 #
b0000 M
b0000 J
b0000 H
b00000000 3
b0000000 5
b0000000 6
b00000000 1
b0000000 -
b0000000 $
0!
0"
0)
0*
0,
$end
#0
b1111 @
b01111 '
1G
b01111 (
b0111 M
b0000110 6
b0111 9
b0111 :
b01111 <
b0111 =
b01111 >
b0111 ?
#1
1L
#6
b1100 A
b1001 B
b01011101 C
1F
0G
b1010 H
b1001 J
b1011000 K
0L
b01001011 N
b00101010 O
b01011101 P
b01001011 Q
b00101010 #
b0000101 $
b01100 %
0*
b01001100 +
0,
b1011101 -
b0100 .
b1001 /
b1011 2
b01011101 3
b1011101 5
b0000000 6
b0000101000 8
b01001 ;
#11
1L
#16
0L
#21
1L
#26
b01001100 1
1D
0L
#31
1L
#36
0L
#41
1L
#46
b1010 A
b10101010 #
b01010011 C
b01010 %
0F
b01001010 +
0L
b1010011 -
b10101010 O
b01010011 P
b01001010 1
b01010011 3
b1010011 5
17
#51
1L
#56
0L
#61
1L
#66
b1000 A
b00101010 #
b01111101 C
b10000 %
1F
b01010000 +
b1111000 K
0L
b1111101 -
b01001111 N
b1010 /
b00101010 O
b01111101 P
b01010000 1
b01001111 Q
b1111 2
b01111101 3
b1111101 5
07
b01010 ;
#71
1L
#76
0L
#81
1L
#86
b0000 A
b0101 B
b00000000 C
0F
1I
b0000 J
b1010000 K
0L
b10101010 N
b00000000 P
b10101010 Q
b1010000 $
b00000 %
b10000 &
b11111 (
1)
b10000000 +
b0000000 -
b0000 .
b0000 /
b10000000 1
b1010 2
b00000000 3
b0000000 5
b0000110 6
17
b1010000000 8
b10000 ;
b11111 <
b1111 ?
#91
1L
#96
0L
#101
1L
#106
b1010 A
b1111 B
b01001111 C
b0000001 $
b01010 %
1F
0)
b1111 J
b11111010 +
0L
b1001111 -
b1010 .
b11111010 N
b1111 /
b01001111 P
b11111010 1
b11111010 Q
b01001111 3
b1001111 5
b0000000 6
b0000001010 8
b11111 ;
#111
1L
#116
0L
#121
1L
#126
b00000000 #
0D
0L
b00000000 N

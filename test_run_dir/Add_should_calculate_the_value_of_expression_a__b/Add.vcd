$date
2024-10-15T14:30+0000
$end
$version
0.2
$end
$comment

$end
$timescale 1ns  $end
$scope module Add $end
 $var wire 4 ! shift $end
 $var wire 7 " shiftedCalcValue $end
 $var wire 1 # subtract $end
 $var wire 8 $ a_data $end
 $var wire 4 % resultFraction $end
 $var wire 1 & compare $end
 $var wire 1 ' subtraction $end
 $var wire 4 ( tempExponent $end
 $var wire 1 ) isResultNaN $end
 $var wire 2 * status_lo $end
 $var wire 2 + roundingMode $end
 $var wire 4 , exponent_1 $end
 $var wire 1 - resultSign $end
 $var wire 5 . roundedFraction $end
 $var wire 7 / tempFraction $end
 $var wire 8 0 greaterOperand_data $end
 $var wire 2 1 status_hi_hi $end
 $var wire 8 2 paddedCalcValue $end
 $var wire 4 3 smallerOperandFraction $end
 $var wire 8 4 smallerOperand_data $end
 $var wire 3 5 status_hi $end
 $var wire 10 6 shiftedFraction_shifted $end
 $var wire 1 7 enable $end
 $var wire 1 8 addOne $end
 $var wire 1 9 reset $end
 $var wire 4 : resultExponent $end
 $var wire 5 ; status $end
 $var wire 3 < shift_1 $end
 $var wire 4 = fraction $end
 $var wire 5 > resultStatus $end
 $var wire 7 ? smallerOperandFraction_1 $end
 $var wire 1 @ NaNFractionValue $end
 $var wire 1 A sign $end
 $var wire 1 B overflow $end
 $var wire 5 C exponent $end
 $var wire 7 D greaterOperandFraction_1 $end
 $var wire 1 E clock $end
 $var wire 4 F greaterOperandFraction $end
 $var wire 8 G b_data $end
 $var wire 1 H isOnlySmallerDenormalized $end
 $var wire 8 I originalCalculatedValue $end
 $var wire 8 J calculatedValue $end
 $var wire 1 K isResult0 $end
$upscope $end
$enddefinitions $end
$dumpvars
b0000000000 6
07
08
b00 1
09
b0000000 D
b00000000 $
b0000 F
0@
0A
0B
b0000000 ?
0E
b000 5
b00 +
b00 *
0H
b00000000 2
0K
b00000000 4
b00000 .
b000 <
b00000000 0
b0000 %
b00000000 J
b0000000 /
b00000000 G
b0000 !
b00000000 I
b0000 ,
b00000 ;
b0000000 "
b0000 (
b00000 >
b00000 C
b0000 3
0#
0&
0'
b0000 =
0)
b0000 :
0-
$end
#0
b01 1
b010 5
19
b110 <
b01000 >
#1
1E
#6
b1011000 D
0E
b1011 F
b01001011 G
0H
b01011101 I
b01011101 J
b0100 !
b1011101 "
b00101010 $
b1100 %
0&
b1001 (
b1001 ,
b01100 .
b1011101 /
b01001011 0
b00 1
b01011101 2
b1010 3
b00101010 4
b000 5
b0000101000 6
18
09
b1001 :
b000 <
b00000 >
b0000101 ?
#11
1E
#16
0E
#21
1E
#26
b01001 C
0E
17
b1100 =
#31
1E
#36
0E
#41
1E
#46
b1010011 "
b10101010 $
b1010 %
0E
1'
b01010011 I
b01010011 J
b01010 .
b1010011 /
b01010011 2
b10101010 4
08
b1010 =
#51
1E
#56
0E
#61
1E
#66
b1111101 "
b01010 C
b00101010 $
b1111000 D
b1000 %
0E
b1111 F
0'
b01001111 G
b01111101 I
b01111101 J
b10000 .
b1111101 /
b01001111 0
b01111101 2
b00101010 4
18
b1010 :
b1000 =
#71
1E
#76
0E
#81
1E
#86
1A
b00000 C
b1010000 D
0E
b1010 F
b10101010 G
b00000000 I
b00000000 J
1K
b0000 !
b0000000 "
b0000 %
1'
b0000 (
b01 *
b0101 ,
1-
b00000 .
b0000000 /
b10101010 0
b01 1
b00000000 2
b010 5
b1010000000 6
08
b0000 :
b01001 ;
b110 <
b0000 =
b01001 >
b1010000 ?
#91
1E
#96
0E
#101
1E
#106
b01111 C
0E
b11111010 G
b01001111 I
b01001111 J
0K
b1010 !
b1001111 "
b1010 %
b1111 (
b00 *
b1111 ,
b01010 .
b1001111 /
b11111010 0
b00 1
b01001111 2
b000 5
b0000001010 6
18
b1111 :
b00000 ;
b000 <
b1010 =
b00000 >
b0000001 ?
#111
1E
#116
0E
#121
1E
#126
b00000000 $
0E
07
b00000000 G

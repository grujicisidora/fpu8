$date
2024-10-17T00:11+0000
$end
$version
0.2
$end
$comment

$end
$timescale 1ns  $end
$scope module Convert $end
 $var wire 7 ! shift $end
 $var wire 1 " enable $end
 $var wire 8 # a_data $end
 $var wire 1 $ addOne $end
 $var wire 1 % reset $end
 $var wire 5 & status $end
 $var wire 8 ' result $end
 $var wire 4 ( finalExponent $end
 $var wire 6 ) tempExponent $end
 $var wire 1 * isResultNaN $end
 $var wire 2 + status_lo $end
 $var wire 3 , fraction $end
 $var wire 5 - resultStatus $end
 $var wire 2 . roundingMode $end
 $var wire 8 / z $end
 $var wire 1 0 overflow $end
 $var wire 1 1 saturationMode $end
 $var wire 5 2 result_hi_3 $end
 $var wire 5 3 result_hi_2 $end
 $var wire 5 4 result_hi_1 $end
 $var wire 5 5 roundedFraction $end
 $var wire 1 6 clock $end
 $var wire 5 7 result_hi_5 $end
 $var wire 5 8 result_hi_4 $end
 $var wire 7 9 tempFraction $end
 $var wire 4 : finalFraction $end
 $var wire 2 ; status_hi_hi $end
 $var wire 5 < result_hi $end
 $var wire 1 = isDenormalized $end
 $var wire 3 > status_hi $end
$upscope $end
$enddefinitions $end
$dumpvars
00
01
b00000000 '
06
b00 ;
b00000000 #
b00 .
0=
b000000 )
b00000 &
b00 +
b000 >
b00000 -
b00000000 /
b0000000 9
b00000 3
b00000 2
b00000 5
b00000 4
b00000 7
b00000 8
b00000 <
b0000 (
b000 ,
0"
0$
0%
b0000000 !
b0000 :
0*
$end
#0
b1001001 !
1%
b111000 )
b01 +
b01001 -
b01111 2
b01111 3
b01111 4
b01111 7
b01 ;
b01111 <
1=
b010 >
#1
16
#6
b0000000 !
b01001011 #
0%
b01010110 '
b1010 (
b001010 )
b00 +
b111 ,
b00000 -
b01110 5
06
b01010 8
b1110000 9
b1110 :
b00 ;
0=
b000 >
#11
16
#16
06
#21
16
#26
1"
06
b01010110 /
#31
16
#36
0"
b00000000 #
06
